using UnityEngine;
using SpacetimeDB.Types;

namespace SYSTEM.WavePacket
{
    /// <summary>
    /// Abstract base class for platform-specific wave packet rendering
    /// Handles both flying packets and detailed extraction visuals
    /// </summary>
    public abstract class WavePacketRenderer : MonoBehaviour
    {
        [Header("Visual Settings")]
        [SerializeField] protected float extractionDiscRadius = 20f;
        [SerializeField] protected float extractionDuration = 2f;
        [SerializeField] protected float rotationSpeed = 180f; // degrees per second

        [Header("Ring Configuration")]
        [SerializeField] protected float[] ringRadii = new float[] { 15f, 12.5f, 10f, 7.5f, 5f, 2.5f };
        [SerializeField] protected float ringWidth = 0.6f; // Narrower gaussian for sharper ring separation
        [SerializeField] protected float heightScale = 0.125f; // Height multiplier per packet count

        [Header("Colors")]
        [SerializeField] protected Color colorRed = new Color(1f, 0f, 0f);
        [SerializeField] protected Color colorYellow = new Color(1f, 1f, 0f);
        [SerializeField] protected Color colorGreen = new Color(0f, 1f, 0f);
        [SerializeField] protected Color colorCyan = new Color(0f, 1f, 1f);
        [SerializeField] protected Color colorBlue = new Color(0f, 0f, 1f);
        [SerializeField] protected Color colorMagenta = new Color(1f, 0f, 1f);
        [SerializeField] protected Color colorGrey = new Color(0.5f, 0.5f, 0.5f);

        protected bool isExtracting = false;
        protected float extractionProgress = 0f;

        /// <summary>
        /// Create a flying packet with trajectory animation
        /// Returns the GameObject so caller can manage it
        /// </summary>
        public abstract GameObject CreateFlyingPacket(WavePacketSample[] samples, Vector3 startPosition, Vector3 targetPosition, float speed);

        /// <summary>
        /// Start the detailed extraction visualization
        /// </summary>
        public abstract void StartExtraction(WavePacketSample[] samples, Vector3 orbPosition);

        /// <summary>
        /// Update extraction animation progress (0-1)
        /// </summary>
        public abstract void UpdateExtraction(float progress);

        /// <summary>
        /// End extraction and clean up
        /// </summary>
        public abstract void EndExtraction();

        /// <summary>
        /// Map frequency to color
        /// </summary>
        protected Color GetColorForFrequency(float frequency)
        {
            // Frequency mapping: 0.0=Red, 1.047=Yellow, 2.094=Green, 3.142=Cyan, 4.189=Blue, 5.236=Magenta
            if (Mathf.Abs(frequency - 0.0f) < 0.1f) return colorRed;
            if (Mathf.Abs(frequency - 1.047f) < 0.1f) return colorYellow;
            if (Mathf.Abs(frequency - 2.094f) < 0.1f) return colorGreen;
            if (Mathf.Abs(frequency - 3.142f) < 0.1f) return colorCyan;
            if (Mathf.Abs(frequency - 4.189f) < 0.1f) return colorBlue;
            if (Mathf.Abs(frequency - 5.236f) < 0.1f) return colorMagenta;
            return colorGrey;
        }

        /// <summary>
        /// Map radius to color for ring visualization
        /// Rings: Red(15), Yellow(12.5), Green(10), Cyan(7.5), Blue(5), Magenta(2.5)
        /// </summary>
        protected Color GetColorForRadius(float radius)
        {
            // Match each radius range to its ring color
            if (radius > 13.75f) return colorRed;      // Outer ring: 13.75-15+
            if (radius > 11.25f) return colorYellow;   // 11.25-13.75
            if (radius > 8.75f) return colorGreen;     // 8.75-11.25
            if (radius > 6.25f) return colorCyan;      // 6.25-8.75
            if (radius > 3.75f) return colorBlue;      // 3.75-6.25
            if (radius > 1.25f) return colorMagenta;   // 1.25-3.75
            return colorMagenta;                        // Center: 0-1.25
        }

        /// <summary>
        /// Get ring index (0-5) for a given frequency
        /// </summary>
        protected int GetRingIndexForFrequency(float frequency)
        {
            // Red=0, Yellow=1, Green=2, Cyan=3, Blue=4, Magenta=5
            if (Mathf.Abs(frequency - 0.0f) < 0.1f) return 0;
            if (Mathf.Abs(frequency - 1.047f) < 0.1f) return 1;
            if (Mathf.Abs(frequency - 2.094f) < 0.1f) return 2;
            if (Mathf.Abs(frequency - 3.142f) < 0.1f) return 3;
            if (Mathf.Abs(frequency - 4.189f) < 0.1f) return 4;
            if (Mathf.Abs(frequency - 5.236f) < 0.1f) return 5;
            return -1; // Unknown frequency
        }

        /// <summary>
        /// Calculate weighted average color for mixed composition
        /// </summary>
        protected Color GetDominantColor(WavePacketSample[] samples)
        {
            if (samples == null || samples.Length == 0)
                return colorGrey;

            Color result = Color.black;
            float totalWeight = 0f;

            foreach (var sample in samples)
            {
                Color sampleColor = GetColorForFrequency(sample.Frequency);
                float weight = sample.Count;
                result += sampleColor * weight;
                totalWeight += weight;
            }

            if (totalWeight > 0)
                result /= totalWeight;

            return result;
        }

        /// <summary>
        /// Calculate height at a given radius based on gaussian rings
        /// </summary>
        protected float CalculateHeightAtRadius(float radius, WavePacketSample[] samples)
        {
            float height = 0f;

            foreach (var sample in samples)
            {
                int ringIndex = GetRingIndexForFrequency(sample.Frequency);
                if (ringIndex < 0 || ringIndex >= ringRadii.Length)
                    continue;

                float ringRadius = ringRadii[ringIndex];
                float distanceFromRing = radius - ringRadius;

                // Gaussian falloff
                float gaussian = Mathf.Exp(-(distanceFromRing * distanceFromRing) / (2f * ringWidth * ringWidth));
                height += sample.Count * heightScale * gaussian;
            }

            return height;
        }

        /// <summary>
        /// Calculate color at a given radius using closest ring's color
        /// Prevents color mixing that causes Z-order issues with multiple rings
        /// </summary>
        protected Color CalculateColorAtRadius(float radius, WavePacketSample[] samples)
        {
            if (samples == null || samples.Length == 0)
                return new Color(0, 0, 0, 0); // Transparent, not grey

            // Find the closest ring to this radius
            float closestDistance = float.MaxValue;
            Color closestColor = new Color(0, 0, 0, 0); // Start with transparent
            float closestContribution = 0f;

            foreach (var sample in samples)
            {
                int ringIndex = GetRingIndexForFrequency(sample.Frequency);
                if (ringIndex < 0 || ringIndex >= ringRadii.Length)
                    continue;

                float ringRadius = ringRadii[ringIndex];
                float distanceFromRing = Mathf.Abs(radius - ringRadius);

                // Find closest ring
                if (distanceFromRing < closestDistance)
                {
                    closestDistance = distanceFromRing;
                    closestColor = GetColorForFrequency(sample.Frequency);

                    // Calculate brightness based on gaussian
                    float gaussian = Mathf.Exp(-(distanceFromRing * distanceFromRing) / (2f * ringWidth * ringWidth));
                    closestContribution = sample.Count * gaussian;
                }
            }

            // Use the closest ring's color, modulated by gaussian brightness
            // Normalize brightness (assuming max count of ~20)
            float brightness = Mathf.Clamp01(closestContribution / 5f);
            brightness = Mathf.Max(0.5f, brightness); // Minimum 50% brightness to avoid black holes

            // Always return the closest color (extends ring color to center)
            // Transparency is handled by alpha fadeout in mesh generation, not here
            return closestColor * brightness;
        }
    }

    /// <summary>
    /// Factory for creating platform-appropriate renderer
    /// </summary>
    public static class WavePacketFactory
    {
        public static WavePacketRenderer CreateRenderer(GameObject parent)
        {
#if UNITY_WEBGL && !UNITY_EDITOR
            return parent.AddComponent<WavePacketRenderer_WebGL>();
#else
            return parent.AddComponent<WavePacketRenderer_Native>();
#endif
        }
    }
}
