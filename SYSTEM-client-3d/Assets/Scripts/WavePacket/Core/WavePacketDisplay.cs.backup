using UnityEngine;
using SpacetimeDB.Types;
using System.Diagnostics;

namespace SYSTEM.WavePacket
{
    /// <summary>
    /// Component-based wave packet visualizer
    /// Can render to prefabs, custom meshes, or generate meshes dynamically
    /// </summary>
    public class WavePacketDisplay : MonoBehaviour
    {
        [Header("Settings")]
        [SerializeField] private WavePacketSettings settings;

                [Header("Rendering Mode")]
        [SerializeField] private WavePacketSettings.RenderMode renderMode = WavePacketSettings.RenderMode.GenerateMesh;
        [SerializeField] private GameObject targetPrefab;
        [SerializeField] private MeshFilter targetMeshFilter;
        [SerializeField] private MeshRenderer targetMeshRenderer;

        [Header("Display Mode")]
        [SerializeField] private WavePacketSettings.DisplayMode displayMode = WavePacketSettings.DisplayMode.Static;
        [SerializeField] private bool rotateVisual = true;


        [Header("Current Composition")]
        [SerializeField] private WavePacketSample[] currentComposition;

        private GameObject visualObject;
        private Material visualMaterial;
        private float animationProgress = 0f;
        private bool isAnimating = false;



        void Awake()
        {
            Stopwatch awakeTimer = Stopwatch.StartNew();

            if (settings == null)
            {
                UnityEngine.Debug.LogWarning("No WavePacketSettings assigned! Creating default.");
                settings = ScriptableObject.CreateInstance<WavePacketSettings>();
            }

            // Read display configuration from settings
            displayMode = settings.displayMode;
            rotateVisual = settings.rotateVisual;
            renderMode = settings.renderMode;

            Stopwatch initTimer = Stopwatch.StartNew();
            InitializeVisual();
            initTimer.Stop();

            awakeTimer.Stop();
            UnityEngine.Debug.Log($"[WavePacketDisplay] Awake: {awakeTimer.ElapsedMilliseconds}ms | InitializeVisual: {initTimer.ElapsedMilliseconds}ms");
        }


        void Update()
        {
            if (rotateVisual && visualObject != null)
            {
                visualObject.transform.Rotate(Vector3.up, settings.rotationSpeed * Time.deltaTime);
            }

            if (isAnimating && displayMode != WavePacketSettings.DisplayMode.Static)
            {
                UpdateAnimation();
            }
        }

        public void SetComposition(WavePacketSample[] composition)
        {
            currentComposition = composition;
            RefreshVisualization();
        }

        public void StartAnimation()
        {
            if (displayMode == WavePacketSettings.DisplayMode.Static) return;

            isAnimating = true;
            animationProgress = 0f;
        }

        public void StopAnimation()
        {
            isAnimating = false;
        }

        private void InitializeVisual()
        {
            switch (renderMode)
            {
                case WavePacketSettings.RenderMode.GenerateMesh:
                    CreateGeneratedMeshVisual();
                    break;
                case WavePacketSettings.RenderMode.UsePrefab:
                    CreatePrefabVisual();
                    break;
                case WavePacketSettings.RenderMode.UseExistingMesh:
                    // Use existing mesh filter
                    break;
            }

            CreateMaterial();
        }

        private void CreateGeneratedMeshVisual()
        {
            visualObject = new GameObject("WavePacketVisual");
            visualObject.transform.SetParent(transform);
            visualObject.transform.localPosition = Vector3.zero;
            visualObject.transform.localRotation = Quaternion.identity;
            visualObject.transform.localScale = Vector3.one;

            targetMeshFilter = visualObject.AddComponent<MeshFilter>();
            targetMeshRenderer = visualObject.AddComponent<MeshRenderer>();
        }

        private void CreatePrefabVisual()
        {
            if (targetPrefab == null)
            {
                UnityEngine.Debug.LogError("Target prefab is null!");
                CreateGeneratedMeshVisual();
                return;
            }

            visualObject = Instantiate(targetPrefab, transform);
            visualObject.name = "WavePacketVisual_Prefab";
            visualObject.transform.localPosition = Vector3.zero;

            targetMeshFilter = visualObject.GetComponent<MeshFilter>();
            targetMeshRenderer = visualObject.GetComponent<MeshRenderer>();

            if (targetMeshFilter == null || targetMeshRenderer == null)
            {
                UnityEngine.Debug.LogError("Prefab must have MeshFilter and MeshRenderer!");
            }
        }

        private void CreateMaterial()
        {
            Stopwatch materialTimer = Stopwatch.StartNew();

            Shader shader = settings.customShader;
            if (shader == null)
            {
                shader = Shader.Find("SYSTEM/WavePacketDisc");
                if (shader == null)
                {
                    shader = Shader.Find("Universal Render Pipeline/Lit");
                }
            }

            if (shader != null && targetMeshRenderer != null)
                UnityEngine.Debug.Log($"[WavePacketDisplay] CreateMaterial: Using shader: {shader.name}");
            {
                visualMaterial = new Material(shader);
                targetMeshRenderer.material = visualMaterial;
            }
            else
            {
                UnityEngine.Debug.LogError($"[WavePacketDisplay] CreateMaterial: SHADER NOT FOUND or renderer is null (shader={shader != null}, renderer={targetMeshRenderer != null})");
            }

            materialTimer.Stop();
            UnityEngine.Debug.Log($"[WavePacketDisplay] CreateMaterial: {materialTimer.ElapsedMilliseconds}ms");
        }

        private void RefreshVisualization()
        {
            if (currentComposition == null || currentComposition.Length == 0)
                return;

            Stopwatch refreshTimer = Stopwatch.StartNew();

            float progress = displayMode == WavePacketSettings.DisplayMode.Static ? 1.0f : animationProgress;
            Stopwatch meshGenTimer = Stopwatch.StartNew();
            Mesh mesh = WavePacketMeshGenerator.GenerateWavePacketMesh(currentComposition, settings, progress);
            meshGenTimer.Stop();

            Stopwatch meshAssignTimer = Stopwatch.StartNew();
            if (mesh != null && targetMeshFilter != null)
                UnityEngine.Debug.Log($"[WavePacketDisplay] RefreshVisualization: Mesh created with {mesh.vertexCount} vertices, bounds: {mesh.bounds}");
            {
                targetMeshFilter.mesh = mesh;
            }
            meshAssignTimer.Stop();
            else
            {
                UnityEngine.Debug.LogError($"[WavePacketDisplay] RefreshVisualization: MESH NOT CREATED or MeshFilter null (mesh={mesh != null}, filter={targetMeshFilter != null})");
            }

            refreshTimer.Stop();
            UnityEngine.Debug.Log($"[WavePacketDisplay] RefreshVisualization | Total: {refreshTimer.ElapsedMilliseconds}ms | MeshGen: {meshGenTimer.ElapsedMilliseconds}ms | MeshAssign: {meshAssignTimer.ElapsedMilliseconds}ms");
        }

        private void UpdateAnimation()
        {
            animationProgress += Time.deltaTime / settings.extractionDuration;

            if (displayMode == WavePacketSettings.DisplayMode.Extraction && animationProgress >= 1.0f)
            {
                isAnimating = false;
                animationProgress = 1.0f;
            }
            else if (displayMode == WavePacketSettings.DisplayMode.Animated)
            {
                animationProgress = Mathf.PingPong(Time.time / settings.extractionDuration, 1.0f);
            }

            RefreshVisualization();
        }

        void OnValidate()
        {
            if (Application.isPlaying && currentComposition != null)
            {
                RefreshVisualization();
            }
        }
    }
}
